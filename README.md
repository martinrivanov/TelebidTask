# TelebidTask

Форма за регистрация, реализирана на уеб среда като уеб приложение. Използваните технологии за изработката му са C# за управление на сървърната част и библиотеката ReactJS за клиентската част.

## Сървърна част

Сървърната част най-общо казано бива разделена на три слоя: API, Services и Data. В API слоя получаваме заявките от клиента и след обработка на информацията от по-долните слоеве бива изпратен отговор обратно до него. В Services слоя са имплементирани използваните услуги за обработка на заявките от API слоя. В него е имплементирана цялостната логика, седяща зад API методите. В Data слоя имаме директна връзка с базата данни, като в нея както записваме информация, така и я получаваме и обработваме. Към тази част са добавени и два тестови проекта за API и Services слоя.


### API

Методите на API-то са имплементирани в IdentityController.cs, като те са:

-GetUserById(Guid id) (GET метод който приема Id на потребителя и връща информацията за него при съществуващо Id, докато в другия случай връща грешка от тип NotFound)

-UpdateUser(Guid id, JsonPatchDocument<User> patch) (PATCH метод, който приема потребителско Id, както и JsonPatchDocument<User>, който улеснява правенето на PATCH заявки (пример за JsonPatchDocument<User> заявка - {"op": "replace", "path": "/name", value: "NewName"}), и модифицира информацията за потребителя спрямо зададените параметри, ако такова Id съществува в базата данни, или NotFound, ако не съществува)

-Register(RegistrationUserModel registration) (POST метод, който приема регистрационен модел на потребител, в която се съдържат всички необходими данни за регистрация, и създава нов потребител при условие, че подаденият имейл не съществува вече в базата)

-Login(LoginCredentials credentials) (POST метод, който приема данните от Login полето, проверява дали съществува такъв потребител и дали паролите съвпадат и при успешен резултат връща userId, а при неуспешен връща BadRequest)

-Logout() (POST метод, който сигнализира за излизане от сегашния потребител)

В този слой също така се намират настройките за сървърната част, като регистриране на връзка между услугите и техните интерфейси за имплементиране на Dependency Injection, както и позволяването на употребата на API-то от клиентската част чрез CORS.


### Services

Услугите в това приложение са две: PasswordService и UserService. Първата услуга се отнася за хеширането на потребителските пароли за по-сигурното им съхранение. Втората услуга се обработва заявките, изпратени от потребителя, като в нея е поставена цялостната логика на сървърната част. Методите от тези услуги са:

#### PasswordService

-GenerateSalt() (генерира така наречената "сол", чрез която е уникална за всеки потребител и е добавена към паролата, за да бъдат създадени по-сложни хешове за паролите, като връща като резултат byte[])

-GeneratePasswordHash(string password, byte[] salt) (създаваме хеш за паролата чрез хеш-функцията SHA-256, като първо се взимат битовете от паролата, след което към тях бива прибавена "солта", после новополучената парола се хешира и към нея пак се добавя тази "сол" в началото на паролата и финалната парола бива превърната в String)


#### UserService

-GetUserById(Guid id) (методът прави заявка до Data слоя за търсене на потребител с конкретното Id, като при успешен резултат бива върнат потребителя под формата на UserDTO (User Data Transfer Object), а при неуспешен връща null)

-Login(LoginCredentials credentials) (методът прави заявка до Data слоя за търсене на потребител с конкретният имейл, като при неуспешен резултат се връща null, но при успешен резултат, получената от потребителя парола се хешира с неговата "сол" и нейния хеш се сравнява с този, записан в базата данни, като при неуспешен резултат отново се връща null, а при успешен се връща потребителя като UserDTO)

-Register(RegistrationModel registrationModel) (методът прави заявка за търсене на потребител по имейл, като ако такъв бъде открит, се връща null, докато в обратния случай подадената парола от потребителската заявка ще бъде хеширана, като за потребителя ще бъде създадена "сол", и след това ще се направи заявка до базата да бъде създаден този потребител, като при неуспешно създаване се връща null, а при успешно - UserDTO на потребителя).

-UpdateUser(Guid id, JsonPatchDocument<User> patch) (методът първо търси за потребител с такова Id, като връща null при неуспешен опит, но ако бъде открит такъв потребител, след това се създава копие на потребителската информация, за да може да имаме копие на потребителя преди да приложим patch върху него и така в случай, че паролата бива подменена с нова, то тази парола ще се хешира; след това се прави заявка за модифициране на потребителската информация и връща UserDTO модел)

-MakeUserCopy(User user) (прави копие на вече съществуващ обект User)

-MapUserToUserDTO(User user) (превръща обект User в UserDTO)


